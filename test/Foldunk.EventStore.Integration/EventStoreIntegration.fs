module Foldunk.EventStore.Integration.EventStoreIntegration

open Backend.Carts
open Backend.Favorites
open Domain
open Foldunk
open Swensen.Unquote
open System

#nowarn "1182" // From hereon in, we may have some 'unused' privates (the tests)

/// Needs an ES instance with default settings
/// TL;DR: At an elevated command prompt: choco install eventstore-oss; \ProgramData\chocolatey\bin\EventStore.ClusterNode.exe
let connectToLocalEventStoreNode () = async {
    let localhost = System.Net.IPEndPoint(System.Net.IPAddress.Loopback, 1113)
    let conn = EventStore.ClientAPI.EventStoreConnection.Create(localhost)
    do! conn.ConnectAsync() |> Async.AwaitTask
    return conn }
let createStream eventStoreConnection maxBatchSize =
    let connection          = Foldunk.Stores.EventStore.GesConnection(eventStoreConnection)
    let gateway             = Foldunk.Stores.EventStore.GesGateway(connection, Foldunk.Stores.EventStore.GesStreamPolicy(maxBatchSize))
    let codec               = Foldunk.EventSum.generateJsonUtf8SumEncoder<_>
    Foldunk.Stores.EventStore.GesEventStream(gateway, codec)

type Tests() =
    let createLog () = createLogger ignore

    let createFavoritesService eventStoreConnection = FavoritesService(createStream eventStoreConnection 500)

    [<AutoData>]
    let ``Can roundtrip Favorites, correctly folding the events`` clientId command = Async.RunSynchronously <| async {
        let! conn = connectToLocalEventStoreNode ()
        let log, service = createLog (), createFavoritesService conn

        do! service.Run log clientId command
        let! items = service.Load log clientId

        match command with
        | Favorites.Commands.Favorite (_,skuIds) ->
            test <@ skuIds |> List.forall (fun skuId -> items |> Array.exists (function { skuId = itemSkuId} -> itemSkuId = skuId)) @>
        | _ ->
            test <@ Array.isEmpty items@>
    }

    let createCartServiceWithBatchSize eventStoreConnection batchSize = CartService(createStream eventStoreConnection batchSize)
    let createCartService eventStoreConnection = createCartServiceWithBatchSize eventStoreConnection 500
    let addAndThenRemoveAnItem context cartId skuId log (service: CartService) count =
        let decide (ctx : DecisionContext<_,_>) = async {
            let run cmd = ctx.Execute(Cart.Commands.interpret cmd)
            for _ in 1..count do
                for c in [Cart.Commands.AddItem (context, skuId, 1); Cart.Commands.RemoveItem (context, skuId)] do
                    run c
            return ctx.Complete() }
        service.Run log cartId decide

    let validateCartIsEmpty cartId log (service: CartService) = async {
        let! state = service.Load log cartId
        test <@ Seq.isEmpty state.items @>
    }

    [<AutoData>]
    let ``Can roundtrip Cart against EventStore, correctly folding the events`` context cartId skuId = Async.RunSynchronously <| async {
        let! conn = connectToLocalEventStoreNode ()
        let log, service = createLog (), createCartService conn

        do! addAndThenRemoveAnItem context cartId skuId log service 5
        
        do! validateCartIsEmpty cartId log service
    }

    let createLoggerWithCapture () =
        let capture = LogCaptureBuffer()
        let subscribeLogListeners obs =
            obs |> capture.Subscribe |> ignore
        createLogger subscribeLogListeners, capture

    [<AutoData()>]
    let ``Can roundtrip against EventStore, correctly batching the reads (no compaction)`` context skuId = Async.RunSynchronously <| async {
        // Dont let FsCheck gen the id as we want data generated by shrinks to accumulate in the stream
        let cartId = Guid.NewGuid() |> CartId
        let log, capture = createLoggerWithCapture ()
        let! conn = connectToLocalEventStoreNode ()
        let batchSize = 3
        let service = createCartServiceWithBatchSize conn batchSize

        // The command processing should trigger only a single read and a single write call
        let addRemoveCount = 5
        do! addAndThenRemoveAnItem context cartId skuId log service addRemoveCount
        let expectedEventCount = 2 * addRemoveCount
        test <@ [ "ReadStreamEventsForwardAsync"; "AppendToStreamAsync" ] = capture.ExternalCalls @>

        // Restart the counting
        capture.Clear() 

        // Validate basic operation; Key side effect: Log entries will be emitted to `capture`
        do! validateCartIsEmpty cartId log service

        // Need to read 4 batches to read 10 events in batches of 3
        let expectedBatches = ceil(float expectedEventCount/float batchSize) |> int
        test <@ List.replicate expectedBatches "ReadStreamEventsForwardAsync" = capture.ExternalCalls @>
    }