module Integration.CartIntegration

open Backend.Carts
open Domain
open EventStore.ClientAPI
open Foldunk
open Serilog
open Swensen.Unquote
open System

let createLogger hookObservers =
    LoggerConfiguration()
        .WriteTo.Observers(Action<_> hookObservers)
        .CreateLogger()

type LogCapture() =
    let captured = ResizeArray()
    member __.Subscribe(source: IObservable<Serilog.Events.LogEvent>) =
        source.Subscribe captured.Add
    member __.Clear () = captured.Clear()
    member __.Entries = captured.ToArray()
    member __.ExternalCalls =
        [ for i in captured do
            let hasProp name = i.Properties.ContainsKey name 
            let prop name = (string i.Properties.[name]).Trim '"' 
            if hasProp "ExternalCall" && prop "ExternalCall" = "True" then
                yield prop "Action"]

// Derived from https://github.com/damianh/CapturingLogOutputWithXunit2AndParallelTests
type TestOutputAdapter(testOutput : Xunit.Abstractions.ITestOutputHelper) =
    let formatter = Serilog.Formatting.Display.MessageTemplateTextFormatter("{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} [{Level}] {Message}{NewLine}{Exception}", null);
    let write logEvent =
        use writer = new System.IO.StringWriter()
        formatter.Format(logEvent, writer);
        writer |> string |> testOutput.WriteLine
    member __.Subscribe(source: IObservable<Serilog.Events.LogEvent>) =
        source.Subscribe write

type Tests(testOutputHelper) =
    let output = TestOutputAdapter testOutputHelper
    let subscribe = output.Subscribe >> ignore
    let createLoggerWithCapture () =
        let capture = LogCapture()
        let hook obs =
            obs |> subscribe
            obs |> capture.Subscribe |> ignore
        createLogger hook, capture
    let createLogger () =
        createLogger subscribe

    let createServiceWithInMemoryStore () =
        let store : IEventStream<_,_> = Stores.MemoryStreamStore() :> _
        CartService(store)

    let createServiceWithEventStore batchSize = async {
        let localhost = System.Net.IPEndPoint(System.Net.IPAddress.Loopback, 1113)
        let conn = EventStore.ClientAPI.EventStoreConnection.Create(localhost)
        do! conn.ConnectAsync() |> Async.AwaitTask
        let store = Foldunk.EventStore.GesStreamStore(conn, batchSize)
        let streamer : IEventStream<_,_> = Foldunk.EventStore.GesEventStreamAdapter(store, Foldunk.EventSum.generateJsonUtf8SumEncoder<_>) :> _
        return CartService(streamer) }

    [<AutoData>]
    let ``Basic Flow Execution`` cartId1 cartId2 ((_,skuId,quantity) as args) = Async.RunSynchronously <| async {
        let log, service = createLogger (), createServiceWithInMemoryStore ()
        let decide (ctx: DecisionState<_,_>) = async {
            Cart.Commands.AddItem args |> Cart.Commands.interpret |> ctx.Execute
            return ctx.Complete ctx.State }
        let verify = function
            | { Cart.Folds.State.items = [ item ] } ->
                let expectedItem : Cart.Folds.ItemInfo = { skuId = skuId; quantity = quantity; returnsWaived = false }
                test <@ expectedItem = item @>
            | x -> x |> failwithf "Expected to find item, got %A"
        let actTrappingStateAsSaved cartId = service.Execute log cartId decide
        let actLoadingStateSeparately cartId = async {
            let! _ = service.Execute log cartId decide
            return! service.Load log cartId }
        let! expected = cartId1 |> actTrappingStateAsSaved
        let! actual = cartId2 |> actLoadingStateSeparately 
        test <@ expected = actual @>
        verify expected
        verify actual
    }

    let addAndThenRemoveAllTheThings context cartId skuId log (service: CartService) =
        let decide (ctx : DecisionState<_,_>) = async {
            for _ in 1..5 do
                for c in [Cart.Commands.AddItem (context, skuId, 1); Cart.Commands.RemoveItem (context, skuId)] do
                    ctx.Execute <| Cart.Commands.interpret c
            return ctx.Complete () }
        service.Execute log cartId decide

    let validateCartIsEmpty cartId log (service: CartService) = async {
        let! state = service.Load log cartId
        test <@ Seq.isEmpty state.items @>
    }

    [<AutoData>]
    let ``Can roundtrip against in memory store`` context cartId skuId = Async.RunSynchronously <| async {
        let log, service = createLogger (), createServiceWithInMemoryStore ()

        do! addAndThenRemoveAllTheThings context cartId skuId log service
        
        do! validateCartIsEmpty cartId log service
    }

    [<AutoData()>]
    let ``Can roundtrip against EventStore, correctly batching the reads`` context skuId = Async.RunSynchronously <| async {
        // Dont let FsCheck gen the id as we want data generated by shrinks to accumulate in the stream
        let cartId = Guid.NewGuid() |> CartId
        let log, capture = createLoggerWithCapture ()
        let batchSize = 3
        let! service = createServiceWithEventStore batchSize

        // The read and the write should produce a single external call each
        do! addAndThenRemoveAllTheThings context cartId skuId log service
        test <@ [ "ReadStreamEventsForwardAsync"; "AppendToStreamAsync" ] = capture.ExternalCalls @>

        // Restart the counting
        capture.Clear() 

        // Validate basic operation; Key side effect: Log entries will be emitted to `capture`
        do! validateCartIsEmpty cartId log service

        // Need to read 4 batches to read 10 events in batches of 3
        let expectedBatches = ceil(5.*2./float batchSize) |> int
        test <@ List.replicate expectedBatches "ReadStreamEventsForwardAsync" = capture.ExternalCalls @>
    }