module Integration.CartIntegration

open Backend.Carts
open Domain
open EventStore.ClientAPI
open Foldunk
open Swensen.Unquote
open System

type Tests(testOutputHelper) =
    let testOutput = TestOutputAdapter testOutputHelper
    let createLog () = createLogger (testOutput.Subscribe >> ignore)

    (* ======== Tests against In-memory Store *)

    let createServiceWithInMemoryStore () =
        let store : Handler.IEventStream<_,_> = Stores.MemoryStreamStore() :> _
        CartService(store)

    [<AutoData>]
    let ``Basic tracer bullet, sending a command and verifying the folded result directly and via a reload``
            cartId1 cartId2 ((_,skuId,quantity) as args) = Async.RunSynchronously <| async {
        let log, service = createLog (), createServiceWithInMemoryStore ()
        let decide (ctx: DecisionState<_,_>) = async {
            Cart.Commands.AddItem args |> Cart.Commands.interpret |> ctx.Execute
            return ctx.Complete ctx.State }

        // Act: Run the decision twice...
        let actTrappingStateAsSaved cartId =
            service.Run log cartId decide
        let actLoadingStateSeparately cartId = async {
            let! _ = service.Run log cartId decide
            return! service.Load log cartId }
        let! expected = cartId1 |> actTrappingStateAsSaved
        let! actual = cartId2 |> actLoadingStateSeparately 

        // Assert 1. Despite being on different streams (and being in-memory vs re-loaded) we expect the same outcome
        test <@ expected = actual @>

        // Assert 2. Verify that the Command got correctly reflected in the state, with no extraneous effects
        let verifyFoldedStateReflectsCommand = function
            | { Cart.Folds.State.items = [ item ] } ->
                let expectedItem : Cart.Folds.ItemInfo = { skuId = skuId; quantity = quantity; returnsWaived = false }
                test <@ expectedItem = item @>
            | x -> x |> failwithf "Expected to find item, got %A"
        verifyFoldedStateReflectsCommand expected
        verifyFoldedStateReflectsCommand actual
    }

    let addAndThenRemoveAnItem context cartId skuId log (service: CartService) count =
        let decide (ctx : DecisionState<_,_>) = async {
            let run cmd = ctx.Execute(Cart.Commands.interpret cmd)
            for _ in 1..count do
                for c in [Cart.Commands.AddItem (context, skuId, 1); Cart.Commands.RemoveItem (context, skuId)] do
                    run c
            return ctx.Complete() }
        service.Run log cartId decide

    let validateCartIsEmpty cartId log (service: CartService) = async {
        let! state = service.Load log cartId
        test <@ Seq.isEmpty state.items @>
    }

    [<AutoData>]
    let ``Can roundtrip against in memory store, correctly folding then events`` context cartId skuId = Async.RunSynchronously <| async {
        let log, service = createLog (), createServiceWithInMemoryStore ()

        do! addAndThenRemoveAnItem context cartId skuId log service 5
        
        do! validateCartIsEmpty cartId log service
    }

    (* ======== Tests against EventStore *)

    /// Needs an ES instance with default settings
    /// TL;DR: At an elevated command prompt: choco install eventstore-oss; \ProgramData\chocolatey\bin\EventStore.ClusterNode.exe
    let connectToLocalEventStoreNode () = async {
        let localhost = System.Net.IPEndPoint(System.Net.IPAddress.Loopback, 1113)
        let conn = EventStore.ClientAPI.EventStoreConnection.Create(localhost)
        do! conn.ConnectAsync() |> Async.AwaitTask
        return conn }

    let createServiceWithEventStoreEx conn batchSize =
        let store               = Foldunk.EventStore.GesStreamStore(conn, batchSize)
        let encoder             = Foldunk.EventSum.generateJsonUtf8SumEncoder<_>
        CartService(Foldunk.EventStore.GesEventStreamAdapter(store, encoder))
    let createServiceWithEventStoreBatchingOnly conn batchSize = createServiceWithEventStoreEx conn batchSize

    let createLoggerWithCapture () =
        let capture = LogCaptureBuffer()
        let subscribeLogListeners obs =
            obs |> testOutput.Subscribe |> ignore
            obs |> capture.Subscribe |> ignore
        createLogger subscribeLogListeners, capture

    [<AutoData()>]
    let ``Can roundtrip against EventStore, correctly batching the reads (no compaction)`` context skuId = Async.RunSynchronously <| async {
        // Dont let FsCheck gen the id as we want data generated by shrinks to accumulate in the stream
        let cartId = Guid.NewGuid() |> CartId
        let log, capture = createLoggerWithCapture ()
        let! conn = connectToLocalEventStoreNode ()
        let batchSize = 3
        let service = createServiceWithEventStoreBatchingOnly conn batchSize

        // The command processing should trigger only a single read and a single write call
        let addRemoveCount = 5
        do! addAndThenRemoveAnItem context cartId skuId log service addRemoveCount
        let expectedEventCount = 2 * addRemoveCount
        test <@ [ "ReadStreamEventsForwardAsync"; "AppendToStreamAsync" ] = capture.ExternalCalls @>

        // Restart the counting
        capture.Clear() 

        // Validate basic operation; Key side effect: Log entries will be emitted to `capture`
        do! validateCartIsEmpty cartId log service

        // Need to read 4 batches to read 10 events in batches of 3
        let expectedBatches = ceil(float expectedEventCount/float batchSize) |> int
        test <@ List.replicate expectedBatches "ReadStreamEventsForwardAsync" = capture.ExternalCalls @>
    }