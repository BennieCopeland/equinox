module Foldunk.EventStore.Integration.EventStoreIntegration

open Domain
open Backend
open Foldunk
open Swensen.Unquote
open System

#nowarn "1182" // From hereon in, we may have some 'unused' privates (the tests)

/// Needs an ES instance with default settings
/// TL;DR: At an elevated command prompt: choco install eventstore-oss; \ProgramData\chocolatey\bin\EventStore.ClusterNode.exe
let connectToLocalEventStoreNode () = async {
    let localhost = System.Net.IPEndPoint(System.Net.IPAddress.Loopback, 1113)
    let conn = EventStore.ClientAPI.EventStoreConnection.Create(localhost)
    do! conn.ConnectAsync() |> Async.AwaitTask
    return conn }
let createGesGateway  maxBatchSize eventStoreConnection =
    let connection = Foldunk.Stores.EventStore.GesConnection(eventStoreConnection)
    Foldunk.Stores.EventStore.GesGateway(connection, Foldunk.Stores.EventStore.GesStreamPolicy(maxBatchSize = maxBatchSize))
let createStream eventStoreConnection maxBatchSize codec : IEventStream<_,_> =
    let gateway = createGesGateway eventStoreConnection maxBatchSize
    Foldunk.Stores.EventStore.GesEventStream(gateway, codec) :> _
let createCartServiceEx eventStoreConnection batchSize = Carts.Service(createStream eventStoreConnection batchSize)
let createCartServiceWithEventStoreWithBatchSize batchSize eventStoreConnection = createCartServiceEx batchSize eventStoreConnection
let createCartServiceWithEventStore eventStoreConnection = createCartServiceWithEventStoreWithBatchSize 500 eventStoreConnection

type Tests() =
    let addAndThenRemoveItems_ exceptTheLastOne context cartId skuId log (service: Carts.Service) count =
        let decide (ctx : DecisionContext<_,_>) = async {
            let run cmd = ctx.Execute(Cart.Commands.interpret cmd)
            for i in 1..count do
                run <| Cart.Commands.AddItem (context, skuId, i)
                if not exceptTheLastOne || i <> count then
                    run <| Cart.Commands.RemoveItem (context, skuId)
            return ctx.Complete() }
        service.Run log cartId decide

    let addAndThenRemoveItemsManyTimes context cartId skuId log service count =
        addAndThenRemoveItems_ false context cartId skuId log service count
    let addAndThenRemoveItemsManyTimesExceptTheLastOne context cartId skuId log service count =
        addAndThenRemoveItems_ true context cartId skuId log service count

    let createLoggerWithCapture () =
        let capture = LogCaptureBuffer()
        let subscribeLogListeners obs =
            obs |> capture.Subscribe |> ignore
        createLogger subscribeLogListeners, capture

    [<AutoData()>]
    let ``Can roundtrip against EventStore, correctly batching the reads without compaction`` context skuId = Async.RunSynchronously <| async {
        // Dont let FsCheck gen the id as we want data generated by shrinks to accumulate in the stream
        let cartId = Guid.NewGuid() |> CartId
        let log, capture = createLoggerWithCapture ()
        let! conn = connectToLocalEventStoreNode ()
        let batchSize = 3
        let service = createCartServiceWithEventStoreWithBatchSize batchSize conn

        // The command processing should trigger only a single read and a single write call
        let addRemoveCount = 6
        do! addAndThenRemoveItemsManyTimesExceptTheLastOne context cartId skuId log service addRemoveCount
        let expectedEventCount = 2 * addRemoveCount - 1
        test <@ [ "ReadStreamEventsForwardAsync"; "AppendToStreamAsync" ] = capture.ExternalCalls @>

        // Restart the counting
        capture.Clear()

        // Validate basic operation; Key side effect: Log entries will be emitted to `capture`
        let! state = service.Load log cartId
        test <@ 6 = match state with { items = [{ quantity = quantity }] } -> quantity | _ -> failwith "nope" @>

        // Need to read 4 batches to read 11 events in batches of 3
        let expectedBatches = ceil(float expectedEventCount/float batchSize) |> int
        test <@ List.replicate expectedBatches "ReadStreamEventsForwardAsync" = capture.ExternalCalls @>
    }